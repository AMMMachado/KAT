.. _walkthrough:

KAT Walkthrough
===============

KAT is a multi-purpose toolkit and even we, the authors, have probably not fully
mined all the possible scenarios in which the software can be applied.  This section
however lists some typical applications for which its been used so far.


Comparing R1 v R2 in an Illumina PE dataset
-------------------------------------------

Comparing the k-mer spectra of read 1 to read 2 files of a paired end run gives
you several insights into properties such as shared errors, difference in quality, 
and provides a decent benchmark to compare two similar runs. Here's how to do it::

    kat comp -t 16 -n -o <output_prefix> <R1.fastq> <R2.fastq>

Executing this command counts each fastq file into separate k-mer hashes, then 
creates a matrix of k-mer spectra frequencies in each dataset for each distinct
k-mer.  Finally, a density plot is made of the matrix.  There are a number of 
interesting points in the output of the run.  First, the some basic stats are produced
on the standard output.  Check properties like expected unique size, mean coverages 
for shared/unshared, or the distance measures between the spectra.  These values
are just indicative, but might point a disaster ahead.  The density plot also
provides a visual representation of how much shared errors are affecting your data.
The following plot on the left shows what you would expect to see in this case 
for a completely unbiased homozygous paired end library of S.coelicolor.  However 
in reality, various biases can interfere with sequencing experiment and we
will probably end up with data which isn't quite as clean, such as that shown in 
the plot on the right of an Illumina run of S.cerevisiae S288C.

.. image:: images/simulated_r1_v_r2.png
    :scale: 45%
.. image:: images/real_r1_v_r2.png
    :scale: 45%


It's also useful to examine the shared and unique partitioned spectra between R1 
and R2.  This can be done by using the same matrix file.  The plot below is from
the same S.cerevisiae S288C dataset, generated using the following command line::

    kat plot spectra-mx -n [options] -o <output_file> <matrix>

.. image:: images/real_r1_v_r2_shared.png
    :scale: 40%
    



Detecting GC bias
-----------------

Using KAT it's possible to correlate biases due to GC content. KAT does this by 
combining k-mer frequency with the GC count for each distinct k-mer and representing
the data in a matrix which can be plotted in a similar way to that discussed in
the previous section.  The command to produce a matrix of GC counts to k-mer
frequency is as follows::

    kat gcp -t 16 -o <output_prefix> (<fastq>)+

The following figure shows how GC bias varies depending on the protocols used in
the sequencing experiments: 1) Simulated, 2) PCR-free, 3) PCR after adaptor ligation, 4)
Standard protocol.  In the simulated data 1), there is a clean circle positioned at the expected
GC levels for S.coelicolor, which has a GC rich genome.  In later plots the GC bias 
is visualised by noting the drift towards 50% GC in the later plots.  

.. image:: images/gc_bias_a.png
    :scale: 25%
.. image:: images/gc_bias_b.png
    :scale: 25%
.. image:: images/gc_bias_c.png
    :scale: 25%
.. image:: images/gc_bias_d.png
    :scale: 25%    


Checking library consistency
----------------------------

In most Whole Genome Shotgun projects, you will end up using more than
one library, sometimes it is just a Paired End library and a Long Mate Pair
library, but some other times you could have a dozen libraries of similar or
completely different types. It is a good policy to check obvious incongruence
among libraries before trying to assemble them.

When you are sequencing the same genome, you are randomly sampling across 
it.  Therefore you should have different spectrum originating from different 
experiments, but sampled from the same set. That means than if you decompose your 
spectra on the components being generated by single-copy elements, duplicated elements, 
triplicated elements, and so on, every motif belonging to a component distribution 
should belong to it across samples.


PE vs PE
~~~~~~~~

Paired end sequencing constitutes the bulk of most current efforts on sequencing,
and is used as a benchmark to sample the motifs on the genome. Since this data type
is expected to have the more random distribution and even coverage, it is a
good place to start studying correlation.

The cleanest examples come from simulated data, where the correlation is
virtually perfect as long as belonging to the same distribution, and virtually
inexistent in terms of any biases. Real data tends to show more correlation within 
the same distribution, especially in cases where strong biases are in play.

To compare two PE libraries run the following command::

    kat comp -n -t 16 -o pcrfree_vs_standard pcr_free 'pcr_free.R?.fastq' 'standard.R?.fastq'

Note that the quotes around the inputs at the end of the command line allow you 
to group files together into a single input.  Therefore all files matching
"pcr_free.R?.fastq" are treated as the first input group, and all files matching 
"standard.R?.fastq" are treated as the second input group.  Each group is k-mer
counted separately.  This saves the user wasting time and space cating PE files 
together prior to input into KAT.

The previous command produces only the density plot, so to generate the shared vs 
unique content plot also run::

    kat plot spectra - mx -n [options] -o pcrfree_vs_standard_shared.png <matrix_file>

The following plots compare two PE sequencing experiments in C.fraxinea, showing 
a large motif duplication in one of the experiments.

.. image:: images/pe_v_pe_1_shared.png
    :scale: 33%
.. image:: images/pe_v_pe_1_density.png
    :scale: 33%


Another interesting point to make is shown in the following plots.  Note how the
coverage across the standard protocol is lot more variable than on the PCR-
free in the density plot.  Note also how some kmers are not even sampled.  The shared
content plots highlight that all the content that just gets “lost” on the standard protocol
(middle plot) as soon as you ask for at least 5x kmer coverage (right plot). While this coverage appears to
be on the “error distribution” side, you can see on the red line (content on the
PCR-free sample, not on the standard sample) that real content from the main
frequency distribution is being lost by using that cutoff. This should make you
think carefully about setting those low-coverage cutoffs again!

.. image:: images/pe_v_pe_2_density.png
    :scale: 27%
.. image:: images/pe_v_pe_2_shared_1.png
    :scale: 27%
.. image:: images/pe_v_pe_2_shared_2.png
    :scale: 27%

PE vs LMP
~~~~~~~~~

When using Long Mate Paired data, in a lot of cases the protocol will impose
considerable biases. It is a good idea to check against the PE data for
coherence. Over-representation and absence of motifs are important factors to
check. The presence of motifs coming from the presence of adaptors (in fact
mostly generated on their junction with genomic DNA) is also sometimes spot-
ted.

In the example shwon in the plots below, a LMP run is compared against a PE run, 
both before: 

.. image:: images/pe_v_mp_before_density.png
    :scale: 33%
.. image:: images/pe_v_mp_before_shared.png
    :scale: 33%

... and after (last two plots) the processing according the
guidelines for the Nextera LMP protocol:

.. image:: images/pe_v_mp_after_density.png
    :scale: 33%
.. image:: images/pe_v_mp_after_shared.png
    :scale: 33%

While the motif presence and spectra is certainly better after the processing,
there is content loss and the biases are clearly visible. You can spot representation 
bias on the density plot for both clusters on the y-axis, both clusters are
too wide and have too large “tails” going up. This is a typical signature for
PCR-generated duplications in some early step in the protocol.

Especially interesting is the use of the shared and unique motifs to spot how
well the LMP library covers the whole genome. It is usually accepted that for
coverages higher than 10 the library should mostly cover the whole genome. If
we look at the content “exclusive” to the PE library as content not covered
by the LMP library, it is obvious that the processing into “good” mate pairs
removes a lot of content. While the spectra of the filtered LMP has better
distribution, it is clear much content is not there. In this case, the library will 
not be very useful for scaffolding.


Contamination detection and extraction
--------------------------------------

Breaking WGS data into k-mers provides a nice way of identifying contamination, or
otherwise unexpected content, in your reads or assemblies.  This section will walk
you through how you might be able to identify and extract contamination in your 
data.


In reads
~~~~~~~~

Contamination detection in your WGS datasets are reliant on the contamination having
differing levels of coverage and/or GC value from your target species.  The process
in KAT is simple::

    kat gcp [options] (WGS_file)+

Running this tool will produce a matrix containing distinct k-mer counts at varying 
frequency and GC value.  It will also produce a plot, such as the one shown here:

.. figure:: images/contaminant_MP.png
    :scale: 50%
    :alt: Contamination detection 1
    :align: center
    :figclass: align-center

    KAT GCP output run through the density plotting tool.  Error k-mers shown at
    very low level with wide GC spread, genuine content between 10-100X with GC 
    spread from 5-25, unexpected content shown at approx 200X with GC 15-25.

The high coverage hot-spot is already suspicious but it becomes even more so after
consider other WGS libraries of the same sample:

.. image:: images/contaminant_ope1.png
    :scale: 33%
.. image:: images/contaminant_ope2.png
    :scale: 33%
.. image:: images/contaminant_PE.png
    :scale: 33%

No other library contains the such a hotspot at GC 15-25.  After merging all libraries
into one the contaminant becomes obvious as the coverage has not altered, meaning
that k-mers in that region where not also found in the other libraries:

.. figure:: images/contaminant_all.png
    :scale: 50%
    :alt: Contamination detection 2
    :align: center
    :figclass: align-center

    After merging all WGS libraries of the same sample, the original suspicious
    region has not altered in coverage.

We can then use the filtering tools in KAT to extract k-mers inside, or outside
defined coverage and GC limits.  In this case we could take the original MP library
and run the following command::

    kat filter kmer --low_count=100 --high_count=250 --low_gc=13 --high_gc=25 <path_to_MP_lib>

This produces a k-mer hash containing only those k-mer found in the defined region.
We can then get the reads (or assembled contigs) associated with these k-mers by
running the following command::

    kat filter seq --threshold=0.5 <path_to_seq_file_to_filter> <filtered_k-mer hash>

BLASTing some of those filtered sequences might then identify the contaminant.


In assemblies
~~~~~~~~~~~~~

Detecting contaminants in assemblies involves a similar process to that described 
in the previous section.  It involves marking contigs in an assembly their average 
k-mer coverage and GC%.  

To obtain the average coverage and GC% scores for each contig use the following
command::

    kat sect [options] <assembly> (WGS_data)+

By extracting the median coverage and gc% columns from the stats file it is possible
to create a scatter plot which can be used in a similar way to that described in
the previous section.

A second use case assumes you already know the contaminant genome and have
access to the reference assembly of that contaminant.  In this case you can 
directly inspect your assembly for signs of the contaminant using the following command::

    kat sect [options] <assembly> <contaminant_genome>

This counts k-mers in the contaminant genome and applies them to sequences in your
assembly.  By reverse sorting the stats file produced by the "%_non_zero_corrected" column
you can identify contigs belonging to the contaminant.  Normally, assuming the 
contaminant is the exact same species as that found in your assembly you expect
to see very high percentage scores (> 90%).  Moderate scores (20-80%) might indicate
either some shared content or chimeric sequences and should be investigated more
thoroughly.



Finding repetitive genomic regions
----------------------------------

Sometimes it's useful to identify regions in a dataset that are repetitive.  This
can easily be done with the following command::

    kat sect -E -F [options] <genome_file> <genome_file>

This counts k-mers in the provided assembly and then marksup the assembly with
those k-mer counts at each position.  Regions that have a count of 1 are extracted
into a new FastA file containing non-repetitive content.  Regions that have a count
of 2-20 (maximum threshold can be adjusted) are extracted to FastA file containing
the repetitive content.


Checking RNAseq consistency with genomic content
------------------------------------------------

Sometimes we find ourselves doing transcriptomics on species without a reference 
genome. It can be useful to analyse where the motifs from our
RNA-seq experiments lie with respect to a genomic sample, which is a lot easier
to generate than a reference genome. To confirm that most of the content of the
RNA-seq is found on the genomic sample, and belongs positions corresponding
to the zones usually related to genic content (i.e., relatively unique regions) is
a good check, but what’s even better, this kind of analysis can help to decide
which sample to use or which genomic/transcriptomic samples analysis will be
easier to do.

The distribution of the shared content on the genomic set will give up the
corresponding genomic loci location on you spectra and allows for interesting comparisons. 
For example, if we have genomic samples from 2 individuals, and a set of rna-seq 
datasets from the same species, we can try to figure out which genomic sample is
going to map more content for each of the rna-seq datasets.  That is exactly the 
case in a set of P.micrantha rna-seq runs shown below:

.. image:: images/pe_v_rna_shared.png
    :scale: 40%
.. image:: images/pe_v_rna_bar.png
    :scale: 40%

The genomes are not yet fully assembled, and actually one of the genomic samples 
is a lot better assembled, because we have extra LMP data on it. By measuring how 
many k-mers are on this distributions, we can both know which genomic sample is 
closer to each rna-seq sample, and also an approximation of the amount of k-mers 
“matched” on each rna-seq dataset.


Assembly analysis using k-mer spectra
-------------------------------------

One of the most frequently used tools in KAT are the so called assembly spectra
copy number plots. We use this as a first at-a-glance analysis for assembly coherence
to the data on the reads they are representing. Basically we represent how many elements
of each frequency on the read’s spectrum ended up included only once in the
assembly, how many two times, etc. In addition to how many where not included at all.

As a simple example to start with, we can look at what a plot for S.cerevesiae S288C 
would look if we happen to perfectly reconstruct the reference assembly::

    kat comp -t 16 -o pe_vs_assembly 'PE.R?.fastq' assembly.fa

.. image:: images/pe_v_asm_clean.png
    :scale: 40%

The errors are absent on the assembly, the main unique content is all there,
exactly once, and all the other distributions are perfectly in place. But from the 
same sequencing, by choosing a wrong k value (too large in this case) and just 
running a typical assembly job, we can end up with something more interesting. 
It is easy to spot missing content, alongside duplications and triplications 
(and quadruplications and so on) that should not be there.

Heterozygous genomes produce more interesting and complex plots, since the k-mer 
spectra clearly shows different distributions for both the heterozygous and the 
homozygous content.  The following plots show what a perfect assembly should look 
like.  In the first case we have a single haplotype mosaic, where the bubbles are
collapsed, which is what we typically would expect to get out of a perfect assembly, 
although it's worth pointing out that some content is clearly lost when we do this.  
In the second case haplotypes are separated producing a lot of duplicated content 
in the homozygous regions, but this allows us to fully capture the heterozygous
content.  We don't typically, aim for the second scenario when assembling genomes.

.. image:: images/heterozygous_perfect_1.png
    :scale: 50
.. image:: images/heterozygous_perfect_2.png
    :scale: 50%

Interestingly though, most assemblies don’t look like either case at all, presenting 
duplications, inclusion of extra variation, etc:

.. image:: images/heterozygous_real.png
    :scale: 75%


Spectra distribution copy number analysis script
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When the spectrum is clean, then a lot about the assembly can be said
by just looking at the copy number plot. By counting how many elements lie on
each “stripe” we can potentially evaluate how much of the unique content
has been duplicated, or how much has not been included at all.  To make this analysis 
possible, we have included an extra script, not yet part of the KAT binary, that 
analyses and fits distributions to the peaks, estimating the counts for the elements 
on the stripes. The final output is a report of the content on each peak divided 
by the stripes with counts based on the distribution fitting.

WARNING: this script is still experimental, we are working on making it release-quality.

To run the script use the following command line::

    kat_dist_analysis.py assembly_main.mx 4 170 5 50000000

So the script as of now takes the following parameters:

 - Number of CNs to consider: As an example, if this value is 4 the distributions corresponding to cn0, cn1, cn2 and cn3+ will be analysed.

 - Max frequency cutoff: The analysis will be done up to this frequency.
 - Min perc: Any new distribution that adds less to min perc kmers on the iterative analysis will not be added.
 - Min elem: Any new distribution that adds less to min elem kmers on the iterative analysis will not be added.

Right now you might need to fiddle a bit with the parameters to get the
script to pick up your distributions correctly, we are working on getting this to
be easier and better.

Since the genes are mostly expected to be in the “unique” content part of the
genome, the analysis of the content of the unique peak can be used to predict
how much of the desired content will be represented on the assembly. In fact,
the metric can be though as how much of the information from the spectra has
been incorporated in the assembly.

.. image:: images/dist_analysis.png
    :scale: 50%