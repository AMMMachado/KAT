//  ********************************************************************
//  This file is part of KAT - the Kmer Analysis Toolkit.
//
//  KAT is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  KAT is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with KAT.  If not, see <http://www.gnu.org/licenses/>.
//  *******************************************************************

#pragma once

#include <getopt.h>
#include <stdlib.h>
#include <iostream>
#include <stdint.h>

using std::cout;
using std::cerr;
using std::endl;


// Add any constants here
#define DEFAULT_OUTPUT_PREFIX "./kat_gcp_output"
const uint16_t  DEFAULT_THREADS         = 1;
const bool      DEFAULT_BOTH_STRANDS    = false;

// Change class name to whatever is appropriate
class GcpArgs
{
public:

    const char * db_arg;
    const char * output_prefix;
    uint16_t threads_arg;
    bool both_strands;
    bool verbose;

    // Default constructor (add default settings here)
    GcpArgs() :
    output_prefix(DEFAULT_OUTPUT_PREFIX), threads_arg(DEFAULT_THREADS), both_strands(DEFAULT_BOTH_STRANDS), verbose(false)
    {}

    // Constructor that parses command line options
    GcpArgs(int argc, char* argv[]) :
    output_prefix(DEFAULT_OUTPUT_PREFIX), threads_arg(DEFAULT_THREADS), both_strands(DEFAULT_BOTH_STRANDS), verbose(false)
    {
        parse(argc, argv);
    }



// Modify usage string to your requirements
#define gcp_args_USAGE "Usage: kat gcp db_path\n"
    const char * usage() const
    {
        return gcp_args_USAGE;
    }

    void error(const char *msg)
    {
        cerr << endl
             << "Error: " << msg << endl << endl
             << usage() << endl
             << "Use --help for more information" << endl << endl;
        exit(1);
    }

// Modify help string to your requirements
#define gcp_args_HELP "Template Help\n\n" \
  "Options (default value in (), *required):\n" \
  " -o, --output_prefix  Prefix path for all output files generated by this tool (" DEFAULT_OUTPUT_PREFIX ").\n" \
  " -t, --threads        The number of threads to use (1).\n" \
  " -C, --both_strands   IMPORTANT: Whether the jellyfish hashes contains kmers produced for both strands.\n" \
  "                      If this is not set to the same value as was produced during jellyfish counting then output from sect will be unpredicatable.\n" \
  " -v, --verbose        Outputs additional information to stderr\n" \
  "     --usage          Usage\n" \
  "     --help           This message\n" \

    const char * help() const
    {
        return gcp_args_HELP;
    }

#define gcp_args_HIDDEN "Hidden options:"
    const char * hidden() const
    {
        return gcp_args_HIDDEN;
    }


    void parse(int argc, char *argv[])
    {
        int c;
        int help_flag = 0;
        int usage_flag = 0;

        static struct option long_options[] =
        {
            {"output_prefix",   required_argument,  0, 'o'},
            {"threads",         required_argument,  0, 't'},
            {"both_strands",    required_argument,  0, 'C'},
            {"verbose",         no_argument,        0, 'v'},
            {"help",            no_argument,        &help_flag, 1},
            {"usage",           no_argument,        &usage_flag, 1},
            {0, 0, 0, 0}
        };

        static const char *short_options = "o:t:Cvuh";

        if (argc <= 1)
        {
            cerr << endl
                 << usage() << endl
                 << help() << endl;
            exit(1);
        }


        while (true)
        {
            /* getopt_long stores the option index here. */
            int index = -1;

            c = getopt_long (argc, argv, short_options, long_options, &index);

            /* Detect the end of the options. */
            if (c == -1)
                break;

            switch (c)
            {
            case ':':
                cerr << "Missing required argument for "
                          << (index == -1 ? std::string(1, (char)optopt) : std::string(long_options[index].name))
                          << endl << endl;
                exit(1);
            case 'h':
                cout << usage() << endl
                     << help() << endl;
                exit(0);
            case 'u':
                cout << usage() << endl
                     << "Use --help for more information." << endl << endl;
                exit(0);
            case '?':
                cerr << "Use --usage or --help for some help" << endl << endl;
                exit(1);
            case 'o':
                output_prefix = optarg;
                break;
            case 't':
                threads_arg = atoi(optarg);
                break;
            case 'C':
                both_strands = true;
                break;
            case 'v':
                verbose = true;
                break;

            }
        }

        if (help_flag)
        {
            cout << usage() << endl
                 << help() << endl;
            exit(0);
        }

        if (usage_flag)
        {
            cout << usage() << endl
                 << "Use --help for more information." << endl << endl;
            exit(0);
        }


        // Parse arguments
        int remaining_args = argc - optind;

        if (verbose)
            cerr << "Found " << remaining_args << " remaining arguments on the command line." << endl;

        // Parse arguments
        if(argc - optind != 1)
            error("Requires exactly 1 argument.");
        db_arg = argv[optind++];
    }

    void print()
    {
        if (verbose)
            cerr << "Verbose flag set" << endl;

        if (threads_arg)
            cerr << "Threads requested: " << threads_arg << endl;

        if (db_arg)
            cerr << "Jellyfish hash: " << db_arg << endl;

        if (output_prefix)
            cerr << "Output prefix: " << output_prefix << endl;

        if (both_strands)
            cerr << "Jellyfish hash to be treated as containing double_stranded information." << endl;

        cerr << endl;
    }

private:
};

