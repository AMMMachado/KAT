//  ********************************************************************
//  This file is part of KAT - the K-mer Analysis Toolkit.
//
//  KAT is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  KAT is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with KAT.  If not, see <http://www.gnu.org/licenses/>.
//  *******************************************************************

#pragma once

#include <getopt.h>
#include <stdlib.h>
#include <iostream>
#include <stdint.h>
#include <vector>

#include <common_args.hpp>
#include <str_utils.hpp>

using std::cout;
using std::cerr;
using std::endl;
using std::vector;
using std::string;
using std::ostringstream;

namespace kat
{
    const string    DEFAULT_OUTPUT_PREFIX   = "kat-gcp";
    const uint16_t  DEFAULT_THREADS         = 1;
    const double    DEFAULT_CVG_SCALE       = 1.0;
    const uint16_t  DEFAULT_CVG_BINS        = 1000;
    const bool      DEFAULT_BOTH_STRANDS    = false;

    const uint16_t  GCP_MIN_ARGS = 1;


    // Change class name to whatever is appropriate
    class GcpArgs : public BaseArgs
    {
    protected:

        // ***********************************************
        // These methods override BaseArgs virtual methods

        const string usage() const
        {
            return "Usage: kat gcp <jellyfish_hash>";
        }

        const string shortDescription() const
        {
            return "Compares GC content and K-mer coverage within a single jellyfish hash.";
        }

        const string longDescription() const
        {
            string long_desc = "This tool takes a single jellyfish hash as input and then counts the GC nucleotides for each distinct K-mer " \
                               "in the hash.  For each GC count and K-mer coverage level, the number of distinct K-mers are counted and " \
                               "stored in a matrix.  This matrix can be used to analyse biological content within the hash.  For example, " \
                               "it can be used to distinguish legitimate content from contamination, or unexpected content.";

            return lineBreakString(long_desc, 78, "  ");
        }

        const string optionsDescription() const
        {
            ostringstream help_str;

            help_str << " -o, --output_prefix=string  Path prefix for files generated by this program (\"" << DEFAULT_OUTPUT_PREFIX << "\")." << endl
                     << " -t, --threads=uint16        The number of threads to use (" << DEFAULT_THREADS << ")." << endl
                     << " -s, --cvg_scale=double      Scaling factor for coverage counts - float multiplier (" << DEFAULT_CVG_SCALE << ").  Max value: 1.0." << endl
                     << " -b, --cvg_bins=uint16       Number of bins for coverage counts (" << DEFAULT_CVG_BINS << ")." << endl
                     << " -C, --both_strands          IMPORTANT: Whether the jellyfish hashes contains K-mers produced for both" << endl
                     << "                             strands.  If this is not set to the same value as was produced during jellyfish" << endl
                     << "                             counting then output from sect will be unpredicatable (" << DEFAULT_BOTH_STRANDS << ").";

            return help_str.str();
        }

        vector<option>* longOptions()
        {
            static struct option long_options_array[] =
            {
                {"output_prefix",   required_argument,  0, 'o'},
                {"threads",         required_argument,  0, 't'},
                {"cvg_scale",       required_argument,  0, 's'},
                {"cvg_bins",        required_argument,  0, 'b'},
                {"both_strands",    no_argument,        0, 'C'}
            };

            vector<option>* long_options = new vector<option>();

            for(uint8_t i = 0; i < 5; i++)
            {
                long_options->push_back(long_options_array[i]);
            }

            return long_options;
        }

        string shortOptions()
        {
            return "o:t:C";
        }

        void setOption(int c, char* option_arg) {

            switch(c)
            {
            case 'o':
                output_prefix = string(option_arg);
                break;
            case 't':
                threads_arg = atoi(option_arg);
                break;
            case 's':
                cvg_scale = atof(option_arg);
                if (cvg_scale > 1.0)
                    cvg_scale = 1.0;
                break;
            case 'b':
                cvg_bins = atoi(option_arg);
                break;
            case 'C':
                both_strands = true;
                break;
            }
        }

        void processRemainingArgs(const vector<string>& remaining_args)
        {
            db_arg = remaining_args[0];
        }

        const string currentStatus() const
        {
            ostringstream status;

            status << "Jellyfish hash: " << db_arg << endl
                   << "Output prefix: " << output_prefix << endl
                   << "Threads requested: " << threads_arg << endl
                   << "Coverage scaling factor: " << cvg_scale << endl
                   << "Coverage bins for matrix: " << cvg_bins << endl
                   << "Jellyfish hash double stranded: " << both_strands << endl;

            return status.str().c_str();
        }

    public:

        string      db_arg;
        string      output_prefix;
        uint16_t    threads_arg;
        double      cvg_scale;
        uint16_t    cvg_bins;
        bool        both_strands;

        // Default constructor (add default settings here)
        GcpArgs() : BaseArgs(GCP_MIN_ARGS),
            output_prefix(DEFAULT_OUTPUT_PREFIX), threads_arg(DEFAULT_THREADS), cvg_scale(DEFAULT_CVG_SCALE), cvg_bins(DEFAULT_CVG_BINS), both_strands(DEFAULT_BOTH_STRANDS)
        {}

        // Constructor that parses command line options
        GcpArgs(int argc, char* argv[]) : BaseArgs(GCP_MIN_ARGS),
        output_prefix(DEFAULT_OUTPUT_PREFIX), threads_arg(DEFAULT_THREADS), cvg_scale(DEFAULT_CVG_SCALE), cvg_bins(DEFAULT_CVG_BINS), both_strands(DEFAULT_BOTH_STRANDS)
        {
            parse(argc, argv);
        }

        ~GcpArgs() {}

    private:
    };
}
